# 单架构

1. 隔离性差
2. 可伸缩性差
3. 可维护性差

# 微服务架构（解决了单体架构的弊端，但同时引入了新的问题）

1. 代码冗余
2. 服务和服务之间存在调用关系
   服务拆分后，服务和服务之间发生的是进程和进程之间的调用，服务器和服务器之间的调用。

   那么就需要发起网络调用，网络调用我们能立马想起的就是 http，但是在微服务架构中，http 虽然便捷方便，但性能较低，这时候就需要引入 RPC（远程过程调用），通过自定义协议发起 TCP 调用，来加快传输效率。

# RPC

RPC 的全称是 Remote Procedure Call ，远程过程调用。这是一种协议，是用来屏蔽分布式计算机中的各种调用细节，使得你可以像是本地调用一样直接调用一个远程的函数。

# 客户端与服务端沟通的过程

1. 客户端发送数据（以字节流的方式）---> 编码
2. 服务端接受并解析。根据约定知道要执行什么，然后把结果返回给客户 ---> 解码

## RPC

1. RPC 就是将上述过程封装下，使其操作更加优化
2. 使用一些大家都认可的协议，使其规范化
3. 做成一些框架，直接或间接产生利益

# gRPC

在 gRPC 中， 我们称调用方为 client ，被调用方为 server 。跟其他的 RPC 框架一样， gRPC 也是基于“服务定义”的思想。简单来讲，就是我们通过某种方式来描述一个服务，这种描述方式是和语言无关的。在这个“服务定义”的过程中，我们描述了我们提供的服务的服务名称是什么，有哪些方法可以被调用，这些方法有什么样的入参，有什么样的回参。

也就是说，在定义好了这些服务，这些方法之后，gRPC 会屏蔽底层的细节，client 只需要直接调用定义好的方法，就能拿到预期的返回结果。对于 server 端来说，还需要实现我们定义的方法。但同样的，gRPC 也会帮助我们屏蔽底层的细节，我们只需要实现所定义的方法的具体逻辑即可。

可以发现，在上面的描述过程中，所谓的“服务定义”，就跟定义接口的语义是很接近的。我更愿意理解为这是一种“约定”，双方约定好接口，然后 server 实现这个接口， client 调用这个接口的代理对象。至于其他的细节，交给 gRPC 。

此外， gRPC 还是与语言无关的。你可以用 C++ 作为服务器，使用 Golang 、 Java 等作为客户端。为了实现这一点，我们在“定义服务”和在编码和解码的过程中，应该是做到与语言无关的。
